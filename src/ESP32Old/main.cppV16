#include <Arduino.h>
#include <WiFi.h>
#include "secrets.h"

WiFiServer server(8888);
WiFiClient client;
unsigned long lastForceMode = 0;
bool bumperPressed = false;

#define BRC_PIN 4

void setup() {
  pinMode(BRC_PIN, OUTPUT);
  digitalWrite(BRC_PIN, HIGH);
  Serial2.begin(115200, SERIAL_8N1, 16, 17);
  WiFi.begin(SECRET_SSID, SECRET_PASS);
  while (WiFi.status() != WL_CONNECTED) delay(500);
  server.begin();
}

void loop() {
  WiFiClient newClient = server.available();
  if (newClient) { client = newClient; client.setNoDelay(true); }

  if (client && client.connected()) {
    // 1. ROS 2 -> Roomba (PRZEKAZYWANIE Z BLOKADĄ)
    if (client.available()) {
      while (client.available()) {
        uint8_t cmd = client.read();
        // Jeśli bumper jest wciśnięty, a ROS2 chce jechać do przodu (bajt 137),
        // ESP32 nadpisuje prędkość na 0.
        if (bumperPressed) {
            // To jest uproszczony bezpiecznik - zatrzymuje każdą komendę Drive (137)
            if (cmd == 137) {
                Serial2.write(137);
                Serial2.write(0); Serial2.write(0); // Vel 0
                Serial2.write(0); Serial2.write(0); // Rad 0
                // Pomijamy kolejne 4 bajty z klienta, bo już wysłaliśmy własny STOP
                for(int i=0; i<4; i++) { while(!client.available()); client.read(); }
                continue;
            }
        }
        Serial2.write(cmd);
      }
    }
    
    // 2. WYMUSZANIE TRYBU
    if (millis() - lastForceMode > 2000) {
      Serial2.write(131); 
      lastForceMode = millis();
    }

    // 3. Roomba -> ROS 2 (ANALIZA SENSORÓW + INIEKCJA)
    if (Serial2.available()) {
      size_t len = Serial2.available();
      uint8_t buf[len];
      Serial2.readBytes(buf, len);

      // Analiza bumperów (Pakiet 100 lub 7 - Bumpery są na początku pakietu)
      // W pakiecie nr 100 (80 bajtów), zderzaki są w bajcie o indeksie 1.
      if (len >= 80) {
        uint8_t bumperByte = buf[1]; 
        // Bity 0 i 1 to Right i Left Bumper
        if ((bumperByte & 0x01) || (bumperByte & 0x02)) {
            bumperPressed = true;
        } else {
            bumperPressed = false;
        }
        
        buf[len - 1] = 2; // Iniekcja trybu Safe dla drivera ROS2
      }

      client.write(buf, len);
    }
  }
}